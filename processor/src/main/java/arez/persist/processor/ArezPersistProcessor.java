package arez.persist.processor;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import org.realityforge.proton.AbstractStandardProcessor;
import org.realityforge.proton.AnnotationsUtil;
import org.realityforge.proton.DeferredElementSet;
import org.realityforge.proton.ElementsUtil;
import org.realityforge.proton.GeneratorUtil;
import org.realityforge.proton.MemberChecks;
import org.realityforge.proton.ProcessorException;

/**
 * Annotation processor that analyzes Arez annotated source and generates models from the annotations.
 */
@SupportedAnnotationTypes( { Constants.PERSIST_TYPE_CLASSNAME,
                             Constants.PERSIST_CLASSNAME } )
@SupportedSourceVersion( SourceVersion.RELEASE_8 )
@SupportedOptions( { "arez.persist.defer.unresolved", "arez.persist.defer.errors", "arez.persist.debug" } )
public final class ArezPersistProcessor
  extends AbstractStandardProcessor
{
  @Nonnull
  private static final Pattern GETTER_PATTERN = Pattern.compile( "^get([A-Z].*)$" );
  @Nonnull
  private static final Pattern ISSER_PATTERN = Pattern.compile( "^is([A-Z].*)$" );
  /**
   * Sentinel value indicating the default value.
   */
  @Nonnull
  private static final String DEFAULT_SENTINEL = "<default>";
  @Nonnull
  private final DeferredElementSet _deferredTypes = new DeferredElementSet();

  @Override
  @Nonnull
  protected String getIssueTrackerURL()
  {
    return "https://github.com/arez/arez-persist/issues";
  }

  @Nonnull
  @Override
  protected String getOptionPrefix()
  {
    return "arez.persist";
  }

  @Override
  public boolean process( @Nonnull final Set<? extends TypeElement> annotations, @Nonnull final RoundEnvironment env )
  {
    // Validate persist first so we don't have to perform validation inside type processing
    // The framework assumes that Arez is also running the annotation processor and validating
    // the shape of the same methods as they are marked as @Observable so this annotation processor
    // performs minimal validation. This can result in this annotation processor producing bad code
    // and the arez annotation processor failing later in the round. The expectation is that we will
    // need to get the arez annotation processor passing and once it does then the code generated by
    // this annotation processor will start to work.
    annotations.stream()
      .filter( a -> a.getQualifiedName().toString().equals( Constants.PERSIST_CLASSNAME ) )
      .findAny()
      .ifPresent( a -> verifyPersistElements( env, env.getElementsAnnotatedWith( a ) ) );

    processTypeElements( annotations, env, Constants.PERSIST_TYPE_CLASSNAME, _deferredTypes, this::process );

    errorIfProcessingOverAndInvalidTypesDetected( env );
    return true;
  }

  private void process( @Nonnull final TypeElement element )
    throws Exception
  {
    if ( !AnnotationsUtil.hasAnnotationOfType( element, Constants.AREZ_COMPONENT_CLASSNAME ) )
    {
      throw new ProcessorException( MemberChecks.must( Constants.PERSIST_TYPE_CLASSNAME,
                                                       "be present on a type annotated with the " +
                                                       MemberChecks.toSimpleName( Constants.AREZ_COMPONENT_CLASSNAME ) +
                                                       " annotation" ),
                                    element );
    }

    final AnnotationMirror annotation =
      AnnotationsUtil.getAnnotationByType( element, Constants.PERSIST_TYPE_CLASSNAME );
    final String name = extractPersistTypeName( element, annotation );
    final boolean persistOnDispose = AnnotationsUtil.getAnnotationValueValue( annotation, "persistOnDispose" );
    final String defaultStore = extractDefaultStore( element, annotation );
    final List<ExecutableElement> methods =
      ElementsUtil.getMethods( element, processingEnv.getElementUtils(), processingEnv.getTypeUtils() );
    final Map<String, PropertyDescriptor> properties = new HashMap<>();
    for ( final ExecutableElement method : methods )
    {
      final AnnotationMirror persistAnnotation =
        AnnotationsUtil.findAnnotationByType( method, Constants.PERSIST_CLASSNAME );
      if ( null != persistAnnotation )
      {
        processPersistAnnotation( element, method, persistAnnotation, methods, defaultStore, properties );
      }
    }

    if ( properties.isEmpty() )
    {
      throw new ProcessorException( MemberChecks.must( Constants.PERSIST_TYPE_CLASSNAME,
                                                       "contain one or more " +
                                                       MemberChecks.toSimpleName( Constants.OBSERVABLE_CLASSNAME ) +
                                                       " properties annotated with " +
                                                       MemberChecks.toSimpleName( Constants.PERSIST_CLASSNAME ) ),
                                    element );
    }

    emitSidecar( new TypeDescriptor( name, persistOnDispose, element, new ArrayList<>( properties.values() ) ) );
  }

  private void processPersistAnnotation( @Nonnull final TypeElement element,
                                         @Nonnull final ExecutableElement method,
                                         @Nonnull final AnnotationMirror persistAnnotation,
                                         @Nonnull final List<ExecutableElement> methods,
                                         @Nonnull final String defaultStore,
                                         @Nonnull final Map<String, PropertyDescriptor> properties )
  {
    final TypeMirror returnType = method.getReturnType();
    if ( TypeKind.VOID == returnType.getKind() )
    {
      throw new ProcessorException( MemberChecks.must( Constants.PERSIST_CLASSNAME,
                                                       "be present on the accessor method of the " +
                                                       MemberChecks.toSimpleName( Constants.OBSERVABLE_CLASSNAME ) +
                                                       " property" ),
                                    method );
    }

    final String persistName = extractPersistName( method, persistAnnotation );
    final String persistStore = extractStore( element, method, persistAnnotation, defaultStore );

    final String setterName = "set" + firstCharacterToUpperCase( persistName );
    final ExecutableElement setter = methods
      .stream()
      .filter( m -> TypeKind.VOID == m.getReturnType().getKind() &&
                    setterName.equals( m.getSimpleName().toString() ) &&
                    1 == m.getParameters().size() &&
                    processingEnv.getTypeUtils().isSameType( m.getParameters().get( 0 ).asType(), returnType ) )
      .findAny()
      .orElse( null );
    if ( null == setter )
    {
      throw new ProcessorException( MemberChecks.must( Constants.PERSIST_CLASSNAME,
                                                       "be paired with a setter named " + setterName ),
                                    method );
    }

    final PropertyDescriptor existing = properties.get( persistName );
    if ( null != existing )
    {
      throw new ProcessorException( MemberChecks.must( Constants.PERSIST_CLASSNAME,
                                                       "has the same name '" + persistName +
                                                       "' as another persistent property declared by the name. " +
                                                       "The other property is accessed by the method named " +
                                                       existing.getGetter().getSimpleName() ),
                                    method );
    }
    else
    {
      properties.put( persistName, new PropertyDescriptor( persistName, persistStore, method, setter ) );
    }
  }

  @Nonnull
  private String extractPersistTypeName( @Nonnull final TypeElement element,
                                         @Nonnull final AnnotationMirror annotation )
  {
    final String declaredValue = AnnotationsUtil.getAnnotationValueValue( annotation, "name" );
    if ( DEFAULT_SENTINEL.equals( declaredValue ) )
    {
      return element.getSimpleName().toString();
    }
    else if ( SourceVersion.isIdentifier( declaredValue ) )
    {
      return declaredValue;
    }
    else
    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_TYPE_CLASSNAME,
                                                          "specify a name parameter that is not a valid java identifier" ),
                                    element,
                                    annotation );
    }
  }

  @Nonnull
  private String extractDefaultStore( @Nonnull final TypeElement element, @Nonnull final AnnotationMirror annotation )
  {
    final String defaultStore = AnnotationsUtil.getAnnotationValueValue( annotation, "defaultStore" );
    if ( !SourceVersion.isIdentifier( defaultStore ) )
    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_TYPE_CLASSNAME,
                                                          "specify a defaultStore parameter that is not a valid java identifier" ),
                                    element,
                                    annotation );
    }
    return defaultStore;
  }

  @Nonnull
  private String extractPersistName( @Nonnull final ExecutableElement method,
                                     @Nonnull final AnnotationMirror annotation )
  {
    final String declaredValue = AnnotationsUtil.getAnnotationValueValue( annotation, "name" );
    final String value = getPropertyAccessorName( method, declaredValue );
    if ( SourceVersion.isIdentifier( value ) )
    {
      return value;
    }
    else
    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_CLASSNAME,
                                                          "specify a name parameter that is not a valid java identifier" ),
                                    method,
                                    annotation );
    }
  }

  @Nonnull
  private String extractStore( @Nonnull final TypeElement typeElement,
                               @Nonnull final ExecutableElement element,
                               @Nonnull final AnnotationMirror annotation,
                               @Nonnull final String defaultStore )
  {
    final String store = AnnotationsUtil.getAnnotationValueValue( annotation, "store" );
    if ( DEFAULT_SENTINEL.equals( store ) )
    {
      return defaultStore;
    }
    else if ( SourceVersion.isIdentifier( store ) )
    {
      if ( defaultStore.equals( store ) &&
           typeElement == element.getEnclosingElement() &&
           ElementsUtil.isWarningNotSuppressed( element, Constants.WARNING_UNNECESSARY_STORE ) )
      {
        final String message =
          MemberChecks.shouldNot( Constants.PERSIST_CLASSNAME,
                                  "specify the store parameter when it is the same as the defaultStore " +
                                  "parameter in the specified by the " +
                                  MemberChecks.toSimpleName( Constants.PERSIST_TYPE_CLASSNAME ) +
                                  " annotation on the enclosing type. " +
                                  MemberChecks.suppressedBy( Constants.WARNING_UNNECESSARY_STORE ) );
        processingEnv.getMessager().printMessage( Diagnostic.Kind.WARNING, message, element );
      }
      return store;
    }
    else

    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_CLASSNAME,
                                                          "specify a store parameter that is not a valid java identifier" ),
                                    element,
                                    annotation );
    }
  }

  private void verifyPersistElements( @Nonnull final RoundEnvironment env,
                                      @Nonnull final Set<? extends Element> elements )
  {
    for ( final Element element : elements )
    {
      assert ElementKind.METHOD == element.getKind();
      if ( !AnnotationsUtil.hasAnnotationOfType( element, Constants.OBSERVABLE_CLASSNAME ) )
      {
        reportError( env,
                     MemberChecks.must( Constants.PERSIST_CLASSNAME,
                                        "be also be annotated with the " + Constants.OBSERVABLE_CLASSNAME +
                                        " annotation" ),
                     element );
      }
    }
  }

  private void emitSidecar( @Nonnull final TypeDescriptor type )
    throws IOException
  {
    final String packageName = GeneratorUtil.getQualifiedPackageName( type.getElement() );
    emitTypeSpec( packageName, SidecarGenerator.buildType( processingEnv, type ) );
  }

  @SuppressWarnings( "SameParameterValue" )
  @Nonnull
  private String getPropertyAccessorName( @Nonnull final ExecutableElement method, @Nonnull final String specifiedName )
    throws ProcessorException
  {
    String name = deriveName( method, GETTER_PATTERN, specifiedName );
    if ( null != name )
    {
      return name;
    }
    if ( method.getReturnType().getKind() == TypeKind.BOOLEAN )
    {
      name = deriveName( method, ISSER_PATTERN, specifiedName );
      if ( null != name )
      {
        return name;
      }
    }
    return method.getSimpleName().toString();
  }

  @Nullable
  private String deriveName( @Nonnull final ExecutableElement method,
                             @Nonnull final Pattern pattern,
                             @Nonnull final String name )
    throws ProcessorException
  {
    if ( DEFAULT_SENTINEL.equals( name ) )
    {
      final String methodName = method.getSimpleName().toString();
      final Matcher matcher = pattern.matcher( methodName );
      if ( matcher.find() )
      {
        final String candidate = matcher.group( 1 );
        return firstCharacterToLowerCase( candidate );
      }
      else
      {
        return null;
      }
    }
    else
    {
      return name;
    }
  }

  @Nonnull
  private String firstCharacterToLowerCase( @Nonnull final String name )
  {
    return Character.toLowerCase( name.charAt( 0 ) ) + name.substring( 1 );
  }

  @Nonnull
  private String firstCharacterToUpperCase( @Nonnull final String name )
  {
    return Character.toUpperCase( name.charAt( 0 ) ) + name.substring( 1 );
  }
}
