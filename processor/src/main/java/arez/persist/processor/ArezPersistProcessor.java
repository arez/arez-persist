package arez.persist.processor;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import org.realityforge.proton.AbstractStandardProcessor;
import org.realityforge.proton.AnnotationsUtil;
import org.realityforge.proton.DeferredElementSet;
import org.realityforge.proton.ElementsUtil;
import org.realityforge.proton.GeneratorUtil;
import org.realityforge.proton.MemberChecks;
import org.realityforge.proton.ProcessorException;

/**
 * Annotation processor that analyzes Arez annotated source and generates models from the annotations.
 */
@SupportedAnnotationTypes( { Constants.PERSIST_TYPE_CLASSNAME,
                             Constants.PERSIST_CLASSNAME } )
@SupportedSourceVersion( SourceVersion.RELEASE_8 )
@SupportedOptions( { "arez.persist.defer.unresolved", "arez.persist.defer.errors", "arez.persist.debug" } )
public final class ArezPersistProcessor
  extends AbstractStandardProcessor
{
  /**
   * Sentinel value indicating the default value.
   */
  @Nonnull
  private static final String DEFAULT_SENTINEL = "<default>";
  @Nonnull
  private final DeferredElementSet _deferredTypes = new DeferredElementSet();

  @Override
  @Nonnull
  protected String getIssueTrackerURL()
  {
    return "https://github.com/arez/arez-persist/issues";
  }

  @Nonnull
  @Override
  protected String getOptionPrefix()
  {
    return "arez.persist";
  }

  @Override
  public boolean process( @Nonnull final Set<? extends TypeElement> annotations, @Nonnull final RoundEnvironment env )
  {
    // Validate persist first so we don't have to perform validation inside type processing
    // The framework assumes that Arez is also running the annotation processor and validating
    // the shape of the same methods as they are marked as @Observable so this annotation processor
    // performs minimal validation. This can result in this annotation processor producing bad code
    // and the arez annotation processor failing later in the round. The expectation is that we will
    // need to get the arez annotation processor passing and once it does then the code generated by
    // this annotation processor will start to work.
    annotations.stream()
      .filter( a -> a.getQualifiedName().toString().equals( Constants.PERSIST_CLASSNAME ) )
      .findAny()
      .ifPresent( a -> verifyPersistElements( env, env.getElementsAnnotatedWith( a ) ) );

    processTypeElements( annotations, env, Constants.PERSIST_TYPE_CLASSNAME, _deferredTypes, this::process );

    errorIfProcessingOverAndInvalidTypesDetected( env );
    return true;
  }

  private void process( @Nonnull final TypeElement element )
    throws Exception
  {
    if ( !AnnotationsUtil.hasAnnotationOfType( element, Constants.AREZ_COMPONENT_CLASSNAME ) )
    {
      throw new ProcessorException( MemberChecks.must( Constants.PERSIST_TYPE_CLASSNAME,
                                                       "be present on a type annotated with the " +
                                                       MemberChecks.toSimpleName( Constants.AREZ_COMPONENT_CLASSNAME ) +
                                                       " annotation"),
                                    element );
    }

    final AnnotationMirror annotation =
      AnnotationsUtil.getAnnotationByType( element, Constants.PERSIST_TYPE_CLASSNAME );
    final String name = extractPersistTypeName( element, annotation );
    final String defaultStore = extractDefaultStore( element, annotation );
    final List<ExecutableElement> methods =
      ElementsUtil.getMethods( element, processingEnv.getElementUtils(), processingEnv.getTypeUtils() );
    final Map<String, PropertyDescriptor> properties = new HashMap<>();
    for ( final ExecutableElement method : methods )
    {
      final AnnotationMirror persistAnnotation =
        AnnotationsUtil.findAnnotationByType( method, Constants.PERSIST_CLASSNAME );
      if ( null != persistAnnotation )
      {
        final TypeMirror returnType = method.getReturnType();
        if ( TypeKind.VOID == returnType.getKind() )
        {
          throw new ProcessorException( MemberChecks.must( Constants.PERSIST_CLASSNAME,
                                                           "be present on the accessor method of the " +
                                                           MemberChecks.toSimpleName( Constants.OBSERVABLE_CLASSNAME ) +
                                                           " property" ),
                                        method );
        }
        //TODO: Verify the return type is one of the variants we handle

        final String persistName = extractPersistName( method, persistAnnotation );
        final String persistStore = extractStore( element, method, persistAnnotation, defaultStore );

        final PropertyDescriptor existing = properties.get( persistName );
        if ( null != existing )
        {
          throw new ProcessorException( MemberChecks.must( Constants.PERSIST_CLASSNAME,
                                                           "has the same name '" + persistName +
                                                           "' as another persistent property declared by the name. " +
                                                           "The other property is accessed by the method named " +
                                                           existing.getGetter().getSimpleName() +
                                                           " property" ),
                                        method );
        }
        else
        {
          properties.put( persistName, new PropertyDescriptor( persistName, persistStore, method ) );
        }
      }
    }

    if ( properties.isEmpty() )
    {
      throw new ProcessorException( MemberChecks.must( Constants.PERSIST_TYPE_CLASSNAME,
                                                       "contain one or more " +
                                                       MemberChecks.toSimpleName( Constants.OBSERVABLE_CLASSNAME ) +
                                                       " properties annotated with " +
                                                       MemberChecks.toSimpleName( Constants.PERSIST_CLASSNAME ) ),
                                    element );
    }

    emitSidecar( new TypeDescriptor( name, element, defaultStore, new ArrayList<>( properties.values() ) ) );
  }

  @Nonnull
  private String extractPersistTypeName( @Nonnull final TypeElement element,
                                         @Nonnull final AnnotationMirror annotation )
  {
    final String declaredValue = AnnotationsUtil.getAnnotationValueValue( annotation, "name" );
    if ( DEFAULT_SENTINEL.equals( declaredValue ) )
    {
      return element.getSimpleName().toString();
    }
    else if ( SourceVersion.isIdentifier( declaredValue ) )
    {
      return declaredValue;
    }
    else
    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_TYPE_CLASSNAME,
                                                          "specify a name parameter that is not a valid java identifier" ),
                                    element,
                                    annotation );
    }
  }

  @Nonnull
  private String extractDefaultStore( @Nonnull final TypeElement element, @Nonnull final AnnotationMirror annotation )
  {
    final String defaultStore = AnnotationsUtil.getAnnotationValueValue( annotation, "defaultStore" );
    if ( !SourceVersion.isIdentifier( defaultStore ) )
    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_TYPE_CLASSNAME,
                                                          "specify a defaultStore parameter that is not a valid java identifier" ),
                                    element,
                                    annotation );
    }
    return defaultStore;
  }

  @Nonnull
  private String extractPersistName( @Nonnull final Element element,
                                     @Nonnull final AnnotationMirror annotation )
  {
    final String declaredValue = AnnotationsUtil.getAnnotationValueValue( annotation, "name" );
    if ( DEFAULT_SENTINEL.equals( declaredValue ) )
    {
      return element.getSimpleName().toString();
    }
    else if ( SourceVersion.isIdentifier( declaredValue ) )
    {
      return declaredValue;
    }
    else
    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_CLASSNAME,
                                                          "specify a name parameter that is not a valid java identifier" ),
                                    element,
                                    annotation );
    }
  }

  @Nonnull
  private String extractStore( @Nonnull final TypeElement typeElement,
                               @Nonnull final ExecutableElement element,
                               @Nonnull final AnnotationMirror annotation,
                               @Nonnull final String defaultStore )
  {
    final String store = AnnotationsUtil.getAnnotationValueValue( annotation, "store" );
    if ( DEFAULT_SENTINEL.equals( store ) )
    {
      return defaultStore;
    }
    else if ( SourceVersion.isIdentifier( store ) )
    {
      if ( defaultStore.equals( store ) &&
           typeElement == element.getEnclosingElement() &&
           ElementsUtil.isWarningNotSuppressed( element, Constants.WARNING_UNNECESSARY_STORE ) )
      {
        final String message =
          MemberChecks.shouldNot( Constants.PERSIST_CLASSNAME,
                                  "specify the store parameter when it is the same as the defaultStore " +
                                  "parameter in the specified by the " +
                                  MemberChecks.toSimpleName( Constants.PERSIST_TYPE_CLASSNAME ) +
                                  " annotation on the enclosing type. " +
                                  MemberChecks.suppressedBy( Constants.WARNING_UNNECESSARY_STORE ) );
        processingEnv.getMessager().printMessage( Diagnostic.Kind.WARNING, message, element );
      }
      return store;
    }
    else

    {
      throw new ProcessorException( MemberChecks.mustNot( Constants.PERSIST_CLASSNAME,
                                                          "specify a store parameter that is not a valid java identifier" ),
                                    element,
                                    annotation );
    }
  }

  private void verifyPersistElements( @Nonnull final RoundEnvironment env,
                                      @Nonnull final Set<? extends Element> elements )
  {
    for ( final Element element : elements )
    {
      assert ElementKind.METHOD == element.getKind();
      if ( !AnnotationsUtil.hasAnnotationOfType( element, Constants.OBSERVABLE_CLASSNAME ) )
      {
        reportError( env,
                     MemberChecks.must( Constants.PERSIST_CLASSNAME,
                                        "be also be annotated with the " + Constants.OBSERVABLE_CLASSNAME +
                                        " annotation" ),
                     element );
      }
    }
  }

  private void emitSidecar( @Nonnull final TypeDescriptor type )
    throws IOException
  {
    final String packageName = GeneratorUtil.getQualifiedPackageName( type.getElement() );
    emitTypeSpec( packageName, SidecarGenerator.buildType( processingEnv, type ) );
  }
}
